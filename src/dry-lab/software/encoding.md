## Primer Generation and Encoding


<!-- toc -->

## Primer Generation

*Contributions*: Lucy, QingRu, Achint, Tina

### Overview
The first Design/Build state is complete, now we are in Testing stage for the primer generation algorithm.

Given a set of requirements, create primers that the wet lab can use for synthesizing ssDNA with TdT. Additionally, demonstrate that our data storage model will not run out of primers, and that we can create more primers to append/make edits to preexisting files [^block].

### Context and Scope
Primers are important for DNA synthesis in our bodies. Usually 5-22 nucleotides long, primers are ssDNA that serve to “prime” or prepare a template strand for an enzyme to bind and initiate DNA synthesis. We will be generating primers with the four bases of DNA, because they are easier to synthesize and more stable than RNA based primers. Unlike DNA polymerase, TdT is unique, and does not require a template strand, so we will be focussing on generating primers that TdT can bind to and initiate DNA synthesis. 

Storage wise, primers act as unique identifiers for the data that is encoded in the information portion of the DNA sequence. Software-wise, the only strict requirement is that it is easy to generate unique primers; however there are biological constraints we must adhere to.

### Goals and non-goals
Goals: Generate primers that confine to these [constraints](https://github.com/UBC-iGEM/dna-software/issues/10), with the goal of ultimately generating acceptable primers for wet lab to order.

Non-goals: Synthesize primers ourselves in the wet lab using this algorithm; this algorithm will be used a few times to get the best primers, then the wet lab will order them. Then this software may be tuned a bit but after wet lab buys primers this piece of software just acts as a conceptual piece to demonstrate POC where we can generate enough primers on the fly, show we won't accidentally allocate two files to the same primer, etc.

### The actual design
* A “genetic algorithm” requires [^genetic]:
    * Start with k randomly generated individuals of specified length
    * Fitness function
* Successors generated by:
    * Selection of two parents by random sampling, as determined by fitness function
    * Crossover
    * Mutation
    * Check against constraints
* This cycle can continue for as many iterations as we want
    * To introduce diversity, we can introduce higher rate of mutations or “annealing temperature” to accept parents of less fitness
* Fitness function determined by constraints, each having a weight or “acceptable” range
    * Primers that fulfill less constraints will have low fitness or be outright rejected
    * For determining melting temperature [^primer] 
    * For determining if secondary structures will form, simple reverse string check is performed, but more advanced checks will be tried in futher iterations [^primer_advanced].

### Diagram
![image](https://github.com/UBC-iGEM/internal-wiki-2023-24/assets/55033656/af702be3-9a33-44b4-992e-d72481255e14)

### How do we test this?
We can use open source tools that evaluate the melting/annealing temperature, secondary structure formation and other constraints to ensure our code is generating acceptable primers.

We can also verify by their use in wet lab, however this may not be feasible given lack of time and resources.

### Storing primers

On a computer, a tree like data structure will be maintained that maps primers to files. Theoretically, only the primers and some metadata is to be stored on the computer, and all the information is stored on the DNA molecules. We will have to quantify our information density.

## Encoding

*Contributions*: Lucy, Riya, Sebastian

<div class="scroll">

![encoding](./images/encoding_dark.png)

</div>

### Overview
Based on a user’s file, we must convert that file to a collection of approximately sized nucleotide sequences for synthesis by wet lab. 

#### Key Points 
1. Segmentation of data: by breaking an input into smaller blocks, we can control how large or how small a strand is to be synthesized. Shorter strands appear to have a smaller rate of error[^aachen].
2. Redundancy: a message is encoded and transmitted using more bits that are necessary to encode the message; a piece of information is redundant if it can be removed without loss of information [^redundancy]. This has either not been explored in depth by other iGEM teams[^github].
3. Primer generation and storing primers.
4. Generating sequences to be encoded.

### Context and Scope
A bit is the most basic form of information a classical computer can interpret, so this means data that is stored and interpreted on a computer is in the form of 0 and 1.

A set of bits can have any meaning if there is no context provided behind how to decode these bits. For text, the mapping from binary sequences to characters is standardized via the UTF-8 (Unicode Transformation Format - 8 bits) standard [^utf]. 

- if we interpreted these bits using UFT-8: 00100100 -> $
- if we interpreted these bits as a number: 00100100 -> 36

UTF-8 is a standardized format for storing and reading characters. UTF-8 encodes for characters, symbols, etc. There are other standards, such as ASCII, which are cover less characters than UTF-8. For instance, 
- 11100000 10100100 10111001
  - using UTF-8: ह
  - using ASCII: à¤¹
    
![utf](https://github.com/UBC-iGEM/internal-wiki-2023-24/assets/55033656/6a2f72ef-bc6c-4a87-b985-0319e0009a8b)

An extra step we take to store information in our DNA storage process is to convert bits to trits. In theory, there is no gain to convert bits to trits because DNA is so dense [^dense]. Additionally, because computers are still binary, having trits instead of bits doesn’t give us any “more” information.

However, compression wise, converting bits to trits gives us an advantage for the context of our project, where we are short on time and resources, and want to synthesize shorter strands. We are able to gain compression when converting bits to trits because the bigger the base you choose to represent a number, the “less” digits you need to store that number. Bits represent numbers in base2 while trits represent numbers in base3. Thus, converting bits to trits allows for higher information density, allow us to use less nucleotides to store information, as compared to leaving the bits as is.

TdT promises to synthesize longer sequences traditional, as compared to chemical based DNA synthesis [^chemical]. However, long nucleotide sequences are more likely to form secondary structures, making synthesis more difficult [^long]. Additionally, given the time and funds of a student design team, we don’t have time to try synthesizing super long sequences. Thus, ease of synthesis can be improved in silico by:
- breaking large files into a collection of short nucleotides, and 
- secondary structure prediction will be attempted on all strands.

Additionally, coupled with a kinetic model, it is possible to try and optimize for base transitions that take less time, while maintaining the previously mentioned points. 

### Goals 
* Convert binary data into nucleotide bases. 
* Collect metadata for error correction during decoding phase 

### The actual design
#### Text
1. To conserve bases for encoding information or error correcting codes, compression of some format will occur
- Text compression algorithms:
  - GZip: https://www.gnu.org/software/gzip/
  - LZ4: [https://github.com/lz4/lz4](https://github.com/lz4/lz4)
  - [https://en.wikipedia.org/wiki/Bzip2](https://en.wikipedia.org/wiki/Bzip2)
2. Convert bits to trits
3. Segment the trits into blocks of trits
4. Using rotation based cipher, generate four nucleotide sequences
5. Choose most stable generated nucleotide sequence 
6.  for every sequence (not applicable for POC)
7. Collect metadata for  and add bases for redundancy if applicable.
8. Give completed nucleotide sequences to wet lab

#### Images (generative, SVG)
As a proof of concept, we can encode images if we put more work on the software to run algorithms to generate images on the spot (similar to SVGs). In the context of Dr. Corbett’s work on [generative bead art](http://joncorbett.ca/research.html).
Could also do image compression: [OpenCV](https://towardsdatascience.com/deep-learning-based-super-resolution-with-opencv-4fd736678066?gi=2a019b394980)

1. We store a color table, and the generic mathematical expression or program that requires this color table and xyz coordinate system to recreate the image of interest. For SVG, we follow the SVG standard for encoding/decoding this image format.
2. Essentially, we have a mathematical function and we are only encoding the inputs to this mathematical expression. 
3. Convert input to bits following the encoding format specific to that image format
4. Similar to above, we convert bits to trits to blocks of trits, then rotation based cipher, and choose the most thermodynamically stable sequence
5. Generate primers (not applicable for POC)
6. Collect metadata, for error correction, adding redundancy (more important in this case)
7. Give completed nucleotide sequences to wet lab.

#### Coupled with error correction 
Refer to [error correction](ecc.md).

### Diagrams
![encode_char](https://github.com/UBC-iGEM/internal-wiki-2023-24/assets/55033656/1729561c-c4d2-44a9-a959-76053ec09654)
![rotation](https://github.com/UBC-iGEM/internal-wiki-2023-24/assets/55033656/bd76a401-2cd4-411a-8425-0c21642684ee) [^archival]

### Current solutions
* Rotation based cipher always starting with “A”: [https://2021.igem.org/Team:Aachen](https://2021.igem.org/Team:Aachen)
* Encoding music (using the extra trit for another layer of representation): [https://www.nature.com/articles/s41467-020-18681-5](https://www.nature.com/articles/s41467-020-18681-5) 
* Re-writable two-dimensional DNA-based data storage with machine learning reconstruction: [https://www.nature.com/articles/s41467-022-30140-x](https://www.nature.com/articles/s41467-022-30140-x) 

### How do we test this?
The robustness of our redundancy, collection of metadata will be evaluated
1. In silico: with software generated faulty DNA sequences 
2. In lab: but probably not enough times to be statistically significant

--- 

[^genetic]: Wu, J. S., Lee, C., Wu, C. C., & Shiue, Y. L. (2004). Primer design using genetic algorithm. Bioinformatics (Oxford, England), 20(11), 1710–1717. https://doi.org/10.1093/bioinformatics/bth147

[^archival]: James Bornholt, Randolph Lopez, Douglas M. Carmean, Luis Ceze, Georg Seelig, and Karin Strauss. 2016. A DNA-Based Archival Storage System. SIGPLAN Not. 51, 4 (April 2016), 637–649. https://doi.org/10.1145/2954679.2872397

[^block]: Puru Sharma, Cheng-Kai Lim, Dehui Lin, Yash Pote, and Djordje Jevdjic. 2023. Efficiently Enabling Block Semantics and Data Updates in DNA Storage. In Proceedings of the 56th Annual IEEE/ACM International Symposium on Microarchitecture (MICRO '23). Association for Computing Machinery, New York, NY, USA, 555–568. https://doi.org/10.1145/3613424.3614308

[^primer]: Addgene. (2019). Addgene: Protocol - How to Design Primers. Addgene.org. https://www.addgene.org/protocols/primer-design/

[^primer_advanced]: Primer Design Guide for PCR :: Learn Designing Primers for PCR. (n.d.). Www.premierbiosoft.com. https://www.premierbiosoft.com/tech_notes/PCR_Primer_Design.html

[^stack]: Primer Dimer / Hairpin Algorithms. (n.d.). Biology Stack Exchange. Retrieved March 11, 2024, from https://biology.stackexchange.com/questions/2818/primer-dimer-hairpin-algorithms

[^github]: igemsoftware2021/Aachen_dna-utils. (2022, November 9). GitHub. https://github.com/igemsoftware2021/Aachen_dna-utils

[^redundancy]: Redundancy. (2020, March 21). Wikipedia. Retrieved 21:56, February 15, 2024 from https://simple.wikipedia.org/w/index.php?title=Redundancy&oldid=6874959.

[^utf]: Wikipedia Contributors. (2019, April 10). UTF-8. Wikipedia; Wikimedia Foundation. https://en.wikipedia.org/wiki/UTF-8

[^chemical]: Eisenstein, M. (2020). Enzymatic DNA synthesis enters new phase. Nature Biotechnology, 38(10), 1113–1115. https://doi.org/10.1038/s41587-020-0695-9

[^long]: rbarcklay. (2020, October 19). Terminal deoxynucleotidyl transferase variants with enhanced thermostability. Intellectual Property Office. https://ipo.lbl.gov/terminal-deoxynucleotidyl-transferase-variants-with-enhanced-thermostability-2019-015/
